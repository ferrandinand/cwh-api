package domain

import (
	"database/sql"
	"encoding/json"
	"strconv"

	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"

	"bitbucket.org/iccgit/icc-cwh-backstage/cwh-api/lib/errs"
	"bitbucket.org/iccgit/icc-cwh-backstage/cwh-api/lib/logger"
)

type VulnerabilityRepositoryDb struct {
	client *sqlx.DB
}

func (c VulnerabilityRepositoryDb) SaveVulnerability(v Vulnerability) *errs.AppError {

	sqlInsertVuln := "INSERT INTO `vulnerabilities` (project_env,project,cluster,app_name,registry,image,installation,reported_on,tenant,critical,high,medium,low,none_count,unknown,vulnerabilities) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"

	vulnerabilitiesJSON, err := json.Marshal(v.Vulnerabilities)
	if err != nil {
		logger.Error("Error while creating new Vulerability report entry: " + err.Error())
		return errs.NewUnexpectedError("Unexpected error from database")
	}

	_, err = c.client.Exec(sqlInsertVuln,
		v.ProjectWithEnv,
		v.Project,
		v.Cluster,
		v.AppName,
		v.Registry,
		v.Image,
		v.Installation,
		v.ReportedOn,
		v.Tenant,
		v.Critical,
		v.High,
		v.Medium,
		v.Low,
		v.None,
		v.Unknown,
		vulnerabilitiesJSON,
	)
	if err != nil {
		logger.Error("Error while creating new vulnerability report: " + err.Error())
		return errs.NewUnexpectedError("Unexpected error from database")
	}

	return nil
}

func (c VulnerabilityRepositoryDb) FindAll(pageId int) (VulnerabilitytList, *errs.AppError) {
	var err error
	var vulnerabilities VulnerabilitytList

	findAllSql := "select id_vulnerability,project_env,project,cluster,app_name,registry,image,installation,reported_on,tenant,critical,high,medium,low,none_count,unknown,vulnerabilities FROM vulnerabilities WHERE reported_on = ? LIMIT ?"
	err = c.client.Select(&vulnerabilities.Items, findAllSql, strconv.Itoa(pageId), pageSize+1)

	if err != nil {
		logger.Error("Error while querying vulnerabilities table " + err.Error())
		return vulnerabilities, errs.NewUnexpectedError("Unexpected database error")
	}

	if len(vulnerabilities.Items) == pageSize+1 {
		vulnerabilities.NextPageID = vulnerabilities.Items[len(vulnerabilities.Items)-1].Id
		vulnerabilities.Items = vulnerabilities.Items[:pageSize]
	}

	return vulnerabilities, nil
}

func (c VulnerabilityRepositoryDb) ById(id string) (VulnerabilitytList, *errs.AppError) {
	var v VulnerabilitytList

	vulnerabilitySql := `SELECT v.id_vulnerability, v.reported_on, v.project_env, v.app_name,
v.project, v.cluster, v.registry, v.image, v.installation, v.tenant, v.critical, 
v.high, v.medium, v.low, v.none_count, v.unknown, v.vulnerabilities
FROM vulnerabilities v
WHERE v.reported_on = (
  SELECT MAX(reported_on)
  FROM vulnerabilities
  WHERE project_env = ?
)
AND v.project_env = ?
ORDER BY v.reported_on ASC`

	err := c.client.Select(&v.Items, vulnerabilitySql, id, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return v, errs.NewNotFoundError("Vulnerability not found")
		} else {
			logger.Error("Error while scanning project " + err.Error())
			return v, errs.NewUnexpectedError("Unexpected database error")
		}
	}

	return v, nil
}
